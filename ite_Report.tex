\documentclass[autodetect-engine,dvi=dvipdfmx,ja=standard,
               a4j,11pt]{bxjsarticle}
\RequirePackage{geometry}
\geometry{reset,paperwidth=210truemm,paperheight=297truemm}
\geometry{hmargin=25truemm,top=20truemm,bottom=25truemm,footskip=10truemm,headheight=0mm}
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage{amsmath}
\usepackage{tabularx}
\renewcommand{\theFancyVerbLine}{\texttt{\footnotesize{\arabic{FancyVerbLine}:}}}
\usepackage{newfloat}
\DeclareFloatingEnvironment[name=Listing, fileext=lol]{eopcode}
\topmargin=-1cm
    \textheight=24cm
    \textwidth=15.5cm
    \oddsidemargin=-.2cm
    \evensidemargin=-.2cm
%%======== レポートタイトル等 ======================================%%
% ToDo: 提出要領に従って，適切なタイトル・サブタイトルを設定する
\title{{\normalsize 情報工学実験A（ハードウェア）報告書}\\
        32ビットマイクロプロセッサの設計    } 

% ToDo: 自分自身の氏名と学生番号に書き換える
\author{氏名: 赤松 佑哉 (akamatsu, YUYA) \\
        学生番号: 09B23595\\
        E-mail: p5785hcf@s.okayama-u.ac.jp}

% ToDo: レポート課題等の指示に従って適切に書き換える
\date{出題日: 2024年5月15日 \\
      提出日: 2024年5月29日 \\
      締切日: 2024年5月29日 \\}  % 注：最後の\\は不要に見えるが必要．


%%======== 本文 ====================================================%%
\begin{document}
\maketitle
\begin{abstract}
本実験では，ハードウェア記述言語およびCAD（Computer Aided Design）ツールを利用したマイクロプロセッサ設計を通じて，
論理回路，コンピュータアーキテクチャ，およびコンピュータシステムに関する理解を深めることを目的とする．
特に，デジタル回路の設計から高位のシステム構築に至る一連の工程を体験することで，ハードウェアとソフトウェアの連携の重要性を理解することを狙いとする．
実験内容としては，まずハードウェア記述言語とCADツールの使用方法を学び，それらを用いた簡単な論理回路の設計を行う．
最終的な目標は，32ビットマイクロプロセッサの設計である．
実験ではまず，ハードウェア記述言語（HDL）とCADツールの使用方法を学び，簡単な論理回路の設計と検証を通して基本的な回路設計の流れを習得した．
次に，それらの知識を応用し，最終的には32ビットマイクロプロセッサの設計を目指す．プロセッサ設計においては，命令のデコード，レジスタファイルの設計，
ALU（算術論理演算器）の構築，制御信号の生成といった基本機能の実装を行った．また，基本的なCPUの演算機能の実現に加えて，
除算や乗算といったやや複雑な演算機能の拡張実装や，加算演算における効率化の手法の導入など，
発展課題にも取り組んだ．
プロセッサ設計の実験では，アセンブラ，シミュレータ，およびハードウェア設計支援システムなど，複数のツールを使用する．
それぞれのツールごとに個別の設定を行わず，すべてのツールに共通する設定ファイルが用意されておりそれらを使用し実験をした．
\end{abstract}
%%============================================================%%
\section{設計したプロセッサの概要}
実際の設計においては，命令を逐次実行する非パイプライン型プロセッサ，処理を高速化した改良版プロセッサ，そして5ステージのパイプラインを導入した高効率プロセッサの，3パターンのアーキテクチャを比較・実装した．
それぞれのプロセッサを\verb|FPGA|にマッピングし，最大動作周波数や消費リソース，処理性能などの観点から詳細な評価を行った．これにより，設計方式の違いが性能や実装規模にどのように影響するかを体系的に比較することができた．
以下に，p32の命令セットの構成，内部構造の特徴，および処理方式の概要について説明する．

\subsection*{(1) 命令セット}
p32は，MIPSアーキテクチャの一部を踏襲した命令セットを備えており，R形式，I形式，J形式という3種類の命令フォーマットを採用している．
基本的な算術演算，論理演算，分岐・ジャンプ，ロード／ストア操作といった主要な命令を網羅しつつも，複雑な命令は省略することで，プロセッサ設計における命令の取り扱いを簡素化している．
以下の表に，p32に実装されている代表的な命令をその機能ごとに分類して示す．

\begin{table}[hbtp]
\centering
\caption{p32の主な命令セット}
\begin{tabularx}{\linewidth}{|l|X|}
\hline
種類 & 命令内容（例） \\
\hline
ロード／ストア命令 & \texttt{lw, sw, lb, sb}：メモリとレジスタ間のデータ転送を行う命令であり，主にデータの読み書きに用いられる． \\ 
\hline
演算命令 & \texttt{add, sub, and, or, xor, nor, sll, srl, sra, addi, subi}：算術演算や論理演算，ビットシフト演算を行う命令群で，レジスタ間または即値との演算に対応する． \\
\hline
条件分岐命令 & \texttt{beq, bne}：2つのレジスタ値を比較し，条件に一致する場合に指定されたアドレスへ分岐する． \\
\hline
ジャンプ命令 & \texttt{j, jal, jr, jalr}：指定されたアドレスへ無条件にジャンプする命令群で，\texttt{jal}や\texttt{jalr}はリンク機能を持ち，サブルーチンの呼び出しに用いられる． \\
\hline
その他 & \texttt{lui, syscall}：上位ビットへの即値ロードやシステムコールの実行など，特殊な機能を提供する補助的な命令． \\
\hline
\end{tabularx}
\end{table}

\subsection*{(2) 内部構造の概略}
p32プロセッサの内部構造は，代表的なRISCプロセッサの設計手法に基づいており，以下のような主要コンポーネントによって構成されている．

\begin{itemize}
\item \textbf{レジスタファイル}：32本の汎用レジスタ（各32ビット幅）を搭載し，2つの読み出しポートと1つの書き込みポートを持つことで，同時に複数のレジスタ操作が可能．
\item \textbf{実行ユニット（ALU・シフタ）}：加算，減算，論理演算（AND, OR, XORなど），およびシフト操作（論理シフト，算術シフト）を1サイクルで実行可能とする．拡張として乗算器や除算器も追加可能であり，将来的な機能拡張も視野に入れて設計されている．
\item \textbf{制御ユニット}：命令のオペコードやファンクションコードを解析し，各ステージに必要な制御信号（レジスタ選択，ALU制御，メモリ制御など）を生成する．
\item \textbf{メモリインターフェース}：命令メモリとデータメモリを明確に分離したハーバードアーキテクチャを採用しており，同時アクセスによる性能向上を図っている．
\item \textbf{メモリアーキテクチャ}：メモリデータの並びはビッグエンディアン形式で管理され，ネットワーク系や組込み系プロセッサに共通する仕様と親和性がある．
\end{itemize}

\subsection*{(3) 処理方式の概略}
p32プロセッサでは，設計初期段階では単純な逐次実行方式を用いていたが，最終的には以下に示す5ステージのパイプラインアーキテクチャを採用することで，命令の同時並行処理と高スループット化を実現した．

\begin{itemize}
\item \textbf{IF（Instruction Fetch）}：命令メモリから次に実行すべき命令を取得する．
\item \textbf{ID（Instruction Decode）}：命令の構文解析を行い，同時にレジスタファイルからオペランドを読み出す．
\item \textbf{EX（Execute）}：ALUやシフタによって算術・論理演算を実行するステージ．条件分岐命令では条件評価も行われる．
\item \textbf{MEM（Memory Access）}：ロードやストア命令においてデータメモリへのアクセスを行うステージ．
\item \textbf{WB（Write Back）}：演算結果やメモリから取得したデータをレジスタファイルに書き戻す．
\end{itemize}

このようなパイプライン処理を導入することにより，複数の命令を重ねて実行することで命令スループットが向上し，プロセッサ全体の実行効率が大幅に改善された．
また，データハザードの発生に対処するため，フォワーディング（バイパス）機構を導入して，依存関係のある命令間でデータを直接転送できるようにしている．
さらに，制御ハザードや構造ハザードに対しては，必要に応じてNOP命令を挿入するなどの手法を取り入れる必要がある．
%%============================================================%%
\section{実施状況の報告}
今回問われた課題について自分の実施状況について以下の表にまとめる．
\begin{table}[b]
    \caption{プログラミング課題，設計課題および発展課題の実施状況}
    \label{tab:プログラミング課題，設計課題および発展課題の実施状況}
    \begin{center}
    {\small
    \begin{tabular}{rll|l}
    \hline
    \hline
    \multicolumn{3}{c|}{課題} & 状況 \\
    \hline
    \multicolumn{3}{l|}{(プログラミング課題)} & \\
    1. & \multicolumn{2}{l|}{【プログラミング課題1】$N$個の語の加算 } & (2)完了 \\
    2. & \multicolumn{2}{l|}{【プログラミング課題2】$N$語のメモリコピー} & (2)完了 \\
    3. & \multicolumn{2}{l|}{【プログラミング課題3】乗算} & (2)完了 \\
    \multicolumn{3}{l|}{(設計課題2)} & \\
    4. & 【設計課題2-1】32ビット加算器   & \verb|add32|          & (2)設計完了 \\
    5. & 【設計課題2-2】32ビットALU      & \verb|alu32|          & (2)設計完了 \\
    6. & 【設計課題2-3】32ビットシフタ   & \verb|shift32|        & (9)非担当 \\
    \multicolumn{3}{l|}{(発展課題2)} & \\
    7. & 【発展課題2-1】32ビット整数乗算器 & \verb|mult32|       & (9)非担当 \\
    8. & 【発展課題2-1】32ビット整数除算器 & \verb|div32|        & (2)設計完了 \\
    \multicolumn{3}{l|}{(設計課題3)} & \\
    9. & 【設計課題3-1】レジスタファイル & \verb|regs32x32|      & (2)設計完了 \\
    10. & 【設計課題3-2】実行ユニット     & \verb|p32ExecUnit|    & (2)設計完了 \\
    11. & 【設計課題3-3】デコードユニット & \verb|p32DecodeUnit|  & (2)設計完了 \\
    \multicolumn{3}{l|}{(設計課題4)} & \\
    12. & 【設計課題4-1】プロセッサ      & \verb|p32m1|          & (2)設計完了 \\
    13. & 【設計課題4-2】プロセッサ      & \verb|p32m2|          & (2)設計完了 \\
    14. & 【設計課題4-3】プロセッサ      & \verb|p32p1|          & (2)設計完了 \\
    \multicolumn{3}{l|}{(発展課題4)} & \\
    15. & 【発展課題4-1】改良            & \verb|add32_cla|      & (2)設計完了 \\
    16. & 【発展課題4-2】乗算機能の実装  &  \verb|p32m12|         & (2)設計完了 \\
    17. & 【発展課題4-3】自由課題        &  \verb|p32m12_v2|      & (1)設計中 \\
    \hline
    \end{tabular}
    }
    \end{center}
    \end{table}
    \clearpage
%%============================================================%%
\section{課題に関する報告}
\subsection{プログラミング課題に関する報告}
\subsubsection{設計課題2-1：32ビット加算器（\texttt{add4}, \texttt{add32}）}

本課題では，32ビットの加算処理を行う加算器\texttt{add32}を設計するにあたり，まず基本単位となる4ビット加算器\texttt{add4}を構成し，それを8個直列に接続することで\texttt{add32}を構成した．

\begin{itemize}
  \item \textbf{add4モジュール}：入力\texttt{a}, \texttt{b}（各4ビット）およびキャリー入力\texttt{cin}を受け取り，4ビットの和\texttt{sum}およびキャリー出力\texttt{cout}を出力する．
  各ビットの桁ごとにキャリービットを順次計算し，次の桁に伝播させることで加算処理を行っている．加算処理には，論理ゲートによるビットごとの組み合わせ論理を用いた．
  
  \item \textbf{add32モジュール}：\texttt{add4}を8段接続し，入力\texttt{a}, \texttt{b}（各32ビット）およびキャリー入力\texttt{cin}に対して，32ビットの加算結果\texttt{sum}，
  最終キャリー出力\texttt{cout}，および符号付き演算におけるオーバーフローを示す\texttt{overflow}を出力する．
  各\texttt{add4}は4ビットずつ加算を行い，キャリーを次段に渡す構成となっており，全体としてリップルキャリー加算器に相当する．
  
  \item \textbf{オーバーフロー検出}：符号付き加算におけるオーバーフロー検出は，入力\texttt{a}と\texttt{b}の最上位ビット（MSB）と加算結果のMSBとの組み合わせにより判定している．
\end{itemize}

以上の構成により，基本的な加算器の動作を段階的に設計・理解することができた．また，より高速な加算器としてキャリールックアヘッド加算器も別途設計・実装・動作確認を行っており，p32プロセッサにおける加算器選定に際して，
速度とリソース使用量のトレードオフについて評価を行う材料とした．(第\ref{tuika_hatten}章参照)

\subsection{設計課題2-2：32ビットALU（\texttt{alu32}）}

本課題では，基本的な算術・論理演算を扱う32ビットALU（算術論理演算器）\texttt{alu32}を設計・実装した．本ALUは，
入力として2つの32ビット値\texttt{a}および\texttt{b}を受け取り，演算結果\texttt{out}，オーバーフロー検出信号\texttt{overflow}，およびゼロフラグ\texttt{zero}を出力する．

\begin{itemize}
  \item \textbf{算術演算}：加算（\texttt{op\_add}）および減算（\texttt{op\_sub}）においては，設計課題2-1で構成した\texttt{add32}モジュールを用いて実装している．減算は2の補数の性質を利用し，入力\texttt{b}のビット反転とキャリーイン\texttt{1}を与えることで実現している．
  \item \textbf{論理演算}：AND，OR，XOR，NORの各演算は，それぞれビットごとの論理演算により直接実現されている．XOR演算は，ビット単位の論理式 \texttt{((a \& \~b) | (\~a \& b))} により実装されている．
  \item \textbf{オーバーフロー検出}：加算と減算においてのみ，符号付き演算に基づいたオーバーフロー検出を行っている．論理演算に関してはオーバーフローが発生しないため，常に\texttt{0}を出力している．
  \item \textbf{ゼロフラグ}：すべての演算において，結果が全ビット0の場合に\texttt{zero}信号が\texttt{1}となるように判定している．
\end{itemize}

この設計により，RISCプロセッサで要求される基本的な算術および論理演算を網羅的にサポートするALUを実現することができた．
シフト演算はグループの他の班員が作成し実装，動作確認済みである．
%%============================================================%%
\subsection{プロセッサ設計課題に関する報告}
\begin{enumerate}
  \item \textbf{シミュレーションによる動作確認} \\
  Quartus Primeに付属するModelSim（あるいは同等のシミュレータ）を用いて、Verilog HDLで記述したプロセッサをシミュレーションした．基本命令（\texttt{add}, \texttt{sub}, \texttt{lw}, \texttt{sw}, \texttt{beq}, \texttt{j} など）を含むテストベンチを作成し，
  命令の逐次実行とレジスタ・メモリの値の変化が期待通りであることを確認した．
  \item \textbf{テストプログラムによる確認}

プロセッサの命令実行機能の動作確認として，アセンブリプログラム \texttt{sum10.s} を用いてテストを行った．このプログラムは，引数として与えられた整数（ここでは10）に対して，その値までの整数を再帰的に加算する関数 \texttt{sum} を呼び出す構成となっており，以下のような特徴を持つ．

\begin{itemize}
  \item 関数呼び出しと戻り：\texttt{jal}, \texttt{jr} 命令を用いた再帰関数呼び出し
  \item スタック操作：レジスタの保存／復元に \texttt{sw}, \texttt{lw} を用い，\texttt{fp} を使用してフレームベースのスタック管理を実装
  \item 分岐命令の使用：条件分岐に \texttt{bne}, 比較に \texttt{slt} を使用
  \item 算術命令の確認：\texttt{addi}, \texttt{add}, \texttt{ori} による加算・即値処理を含む
\end{itemize}

このテストプログラムは，引数 $a_0 = 10$ に対して，$1 + 2 + \dots + 10 = 55$ を求めることを目的としており，実行後にはその結果がレジスタ \texttt{\$v0} に格納される．

\textbf{シミュレーション上での動作確認}では，ModelSim を用いて命令のデコード・実行・メモリアクセスが期待通りに行われることを波形レベルで検証した．
関数呼び出しにおいて \texttt{ra}, \texttt{fp} の保存／復元，および戻りアドレス制御が正しく行われていること，正常に動作したときのサンプル実行結果がシミュレーションの期待結果と
一致することを確認した．
\end{enumerate}
設計したプロセッサは，Intel社のFPGAデバイス \texttt{Cyclone IV E (EP4CE115F29C7)} をターゲットとして，
論理合成・配置配線・静的タイミング解析を実施した．
以下にターゲットデバイスの，各要素についてまとめた表\ref{tab:ターゲットFPGAデバイスとそのリソース量}を以下に示す．\\
\begin{table}[hbtp]
    \caption{ターゲットFPGAデバイスとそのリソース量}
    \label{tab:ターゲットFPGAデバイスとそのリソース量}
    \begin{center}
    \begin{tabular}{l|r}
    \hline \hline
    ターゲットデバイス & Intel Cyclone IV E (EP4CE115F29C7) \\
    Logic Element (LE)数 & 114,480 \\
    レジスタ数 & 114,480 \\
    メモリ容量 (ビット) & 4,981,312\\
    9ビット乗算器 & 432 \\
    \hline
    \end{tabular}
    \end{center}
    \end{table}

正常に，作成したプロセッサが動作していることを確認したのちに各プロセッサについて
動作周波数，ロジックエレメントの数等の記録を以下の表\ref{tab:FPGAへの論理合成等で得られた諸量のまとめ}にまとめた．\\
\begin{table}[hbtp]
    \caption{FPGAへの論理合成等で得られた諸量のまとめ}
    \label{tab:FPGAへの論理合成等で得られた諸量のまとめ}
    \begin{center}
    % 表が大きいので，small サイズのフォントを利用
    {\small
    \begin{tabular}{l|ccccc}
    \hline
    \hline
    モジュール &
    \multicolumn{2}{c}{最大動作周波数 Fmax} & LE数 (使用率) & 
    CF数 (使用率) & レジスタ数 (使用率)  \\
    & 85 $^\circ$C Model & 0 $^\circ$C Model & & &  \\
    \hline
    プロセッサ \verb|p16m1| & 56.85& 61.64& 3764 (3\%) & 3558 (3\%)&  1379 (1 \%) \\
    プロセッサ \verb|p16m2| & 53.41& 58.45& 3,842(3\%)& 3,609 (3\%)&  1377 (1\%)\\
    プロセッサ \verb|p16p1| & 40.52& 43.95& 4,089 (3\%)& 3,995(3\%) & 1,416 (1\%)\\
    \hline
    \multicolumn{6}{r}{（Fmax の単位は MHz）}
    \end{tabular}
    }
    \end{center}
    \end{table}



設計した3種類のプロセッサ（p16m1，p16m2，p16p1）に対して，Intel社製FPGA（Cyclone IV E: EP4CE115F29C7）を
ターゲットとした論理合成・配置配線・静的タイミング解析を行い，得られた各種諸量（最大動作周波数，論理素子使用量，レジスタ数など）
を表\ref{tab:FPGAへの論理合成等で得られた諸量のまとめ}に示した．
さらに，各プロセッサの実行性能（命令数，サイクル数，Fmaxに基づく実行時間）についても比較を行い，
設計上の改良点が結果にどのように反映されたかを定量的に考察できるようにした．

まず，すべてのプロセッサにおいて加算器には，基本課題で設計した単純なリップルキャリー加算器ではなく，
発展課題として実装した**キャリールックアヘッド加算器（Lookahead Carry Adder）**を採用している点に注目したい．
この加算器は，ビットごとにキャリー伝播を待たずに並列に計算する構造を持ち，ALUのクリティカルパスを大幅に短縮することができる．
実際，Fmaxの向上にもつながっており，
各プロセッサで60 MHz前後の最大動作周波数が得られているのはこの発展加算器の貢献によるものである．

\textbf{p16m1}（単純マルチサイクル型）は最も基本的な構成であり，各命令のステージが順番に実行される方式である．
443命令を実行するのに2215サイクルを要し，最終的な実行時間は0.21 $\mu$sであった．
この構成は設計・実装が比較的容易である一方，命令ごとの平均サイクル数は約5.0と高く，効率性の面では他構成に劣る．

\textbf{p16m2}（改良型マルチサイクル）は制御ユニットと状態遷移の最適化を通じて命令の種類に応じた実行ステージ数を柔軟に
設定できるようになっており，443命令に対して1584サイクルと約29\%の削減を実現している．
Fmaxはやや低下（58.45 MHz）しているが，それでも実行時間は0.18 $\mu$sと短縮され，
制御回路の改良が明確に性能向上につながっている．

\textbf{p16p1}（5ステージパイプライン型）は最も複雑な構成であり，命令のIF～WBまでを重ねて実行することで，
大幅なスループット向上を実現している．命令数が508と他構成より多いにもかかわらず，総サイクル数はわずか516であり，
1命令あたりの実行時間が著しく短縮されている．
Fmax自体は43.95 MHzと他より低めではあるが，実行時間は最短の0.065 $\mu$sであり，
パフォーマンス指標として最も優れている結果となった．

他の設計者との比較において，すべてのプロセッサで \texttt{+} 演算子や高位合成ライブラリを用いず，
明示的に加算器を設計したことから，採用した加算器の構造がプロセッサ全体の性能に大きく影響を与えることが明らかとなった．
私は発展課題として，基本課題で用いた単純なリップルキャリー加算器ではなく，
キャリールックアヘッド（CLA: Carry Lookahead Adder）を実装した．
その結果，リップルキャリー加算器を用いた設計と比較して，論理合成結果における最大動作周波数（Fmax）が明確に高く，
処理性能の向上が確認された．
一方で，より高速な並列Prefix加算器（例：Sklansky型やKogge-Stone型）を実装した設計と比較すると，
私の設計はわずかにFmaxや実行時間で劣っていた．
この結果は，プロセッサの設計改善において，加算器が重要な構成要素であることを強く示唆しており，
制御回路やパイプライン構成の工夫よりもまずは加算器の効率化が性能向上に直結することを再認識した．

以上の結果を踏まえると，設計課題および発展課題を通じて実施した各種の改良
（加算器の高速化，制御ロジックの最適化，パイプライン構成の導入など）は，
論理合成結果および実行性能に明確に定量的な効果として現れており，
プロセッサ設計におけるアーキテクチャ選択と低レベル回路最適化の重要性を理解できた．

%%============================================================%%
     
\subsection{追加課題や発展課題に関する報告}\label{tuika_hatten}
\subsubsection{32bit除算器の実装}\label{div}
本発展課題では，32ビットの符号なし除算器（\texttt{div32\_v2}）を自作し，プロセッサに組み込んだ．
本除算器は，\textbf{逐次シフト減算法（Restoring Division）}に基づく構成となっており，
1クロックサイクルごとに商の各ビットを計算していく設計である．
以下に，動作の各ステージを示す：

\begin{itemize}
  \item 初期化：被除数 \texttt{a} を64ビットに拡張し（上位32ビットにゼロ），除数 \texttt{b} およびループカウンタ \texttt{stat} をセットする（1サイクル）。
  \item ループステート（\texttt{st0}）：
  \begin{itemize}
    \item 上位ビット（\texttt{a0[63:32]}）から \texttt{b} を減算し，結果の符号によって商のビットを決定（0 または 1）。
    \item 結果に応じて \texttt{a0} を更新（減算値 or 未変更）し，次のシフト処理へ進む。
    \item \texttt{stat} を1ビット右シフトすることで，ループ回数（全32回）を制御。
  \end{itemize}
  \item 終了ステート（\texttt{st1}）：
  \begin{itemize}
    \item 商（下位32ビット）と剰余（上位32ビット）を \texttt{out\_en} を通じて出力。
  \end{itemize}
\end{itemize}
本除算器は初期化に1サイクル，ループ処理に最大32サイクルを必要とするため，
1回の除算処理におおよそ33サイクルを要する．
従って，演算器としてのスループットは高くはないが，回路構成が比較的単純であり，面積効率が良くFPGA実装にも適している．

また，逐次処理であるため並列性には欠けるものの，演算ごとの結果の精度やデバッグの容易さの観点からは実装・検証しやすい構成
となっている．今後，さらなる高速化を目指す場合は，非復帰除算器（non-restoring division）や 
SRT 除算器，さらにはNewton-Raphson法やGoldschmidt法を用いた除算回路への拡張が考えられる．
\subsubsection{プロセッサの改良}
プロセッサの性能改善を検討する中で，Quartus Prime による静的タイミング解析のレポートを詳細に確認したところ，
\textbf{加算を含む命令（例：\texttt{add}, \texttt{addi}, \texttt{sub}）がクリティカルパスとなっている}ことが判明した．
これは，ALU内の加算器におけるキャリー伝播遅延が，クロック周波数の上限を制約していることを意味しており，
性能ボトルネックとして顕在化していた．
プロセッサのALUにおける加算処理は，命令の多くに共通して含まれる基本演算であり，
その遅延はプロセッサ全体のクロック制約に直結する．従来のリップルキャリー加算器（Ripple Carry Adder, RCA）では，
1ビットごとに
キャリー信号が逐次伝搬するため，全体の遅延がビット数に比例して増加しやすく，特に32ビット幅では遅延が顕著となる．
この問題を解決するため，従来のリップルキャリー加算器（Ripple Carry Adder, RCA）に代えて，
\textbf{32ビット桁上げ先見加算器（Carry Lookahead Adder, CLA）}を自ら実装した．
この加算器は，キャリービットの伝播をグループ単位で並列に計算する構造を持ち，全体の計算遅延を大幅に短縮できる．
しかし32ビットともなると論理演算が複雑となる．桁上げの式は規則性があるためまず，
任意ビット目のキャリーを中間変数だけで表した式を出力する
\verb|C++|プログラムを作成した．
いかにそのコードを示す.
\begin{Verbatim}[numbers=left, xleftmargin=8mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
#include <iostream>
#include <fstream>
#include <string>

using namespace std;

// キャリー c_i の論理式を文字列で生成する関数（セミコロンなし）
string generate_carry_expr(int i) {
    if (i == 0) return "c0 = c0"; // 初期キャリー

    string expr;
    for (int k = 0; k < i; ++k) {
        if (!expr.empty()) expr += " | ";
        expr += "(";
        for (int j = i - 1; j > k; --j) {
            expr += "p" + to_string(j) + " & ";
        }
        expr += "g" + to_string(k) + ")";
    }

    // 最後の項: p[i-1] & ... & p0 & c0
    expr += " | (";
    for (int j = i - 1; j >= 0; --j) {
        expr += "p" + to_string(j) + " & ";
    }
    expr += "c0)";

    return "c" + to_string(i) + " = " + expr;
}

int main() {
    ofstream outfile("CLA.txt");
    if (!outfile) {
        cerr << "CLA.txt を開けませんでした。\n";
        return 1;
    }

    for (int i = 0; i <= 31; ++i) {
        string expr = generate_carry_expr(i);
        outfile << expr << "\n";
    }

    outfile.close();
    cout << "a.txt に c0〜c31 の式を出力しました。\n";
    return 0;
}    
\end{Verbatim}
今回中間変数をデバッグ，可読性のため使用した．使用しなければサイクルを一つ減らせるためわずかに効率が向上するように思えるが
実際には，回路面積が膨大になりフィッティングしみるとかえって遅くなる可能背もある．さらには，可読性が非常に悪くなるので
デバッグが非常に困難である，

本加算器を各種プロセッサ構成（\texttt{p16m1}, \texttt{p16m2}, \texttt{p16p1}）に統一的に導入した結果，
いずれのプロセッサにおいても最大動作周波数（Fmax）が向上し，
明確な性能改善が見られた．
具体的には，\texttt{p16m1}においてFmaxが60.98 MHz，\texttt{p16m2}で58.45 MHz，\texttt{p16p1}でも43.95 MHzを記録しており，
いずれも加算器がボトルネックとなっていた状態から改善が図られたことが定量的に示された．

この経験を通して，演算器，特に加算器の設計がプロセッサ全体の性能に与える影響の大きさを実感するとともに，
単体の回路改善がシステムレベルの最適化へと直結することを学ぶことができた．
\subsubsection{乗算機能の実装}
p32実行ユニット内に32ビット乗算器（\texttt{mult32}）を組み込み、64ビット結果をHI/LOレジスタに格納する方式を採用している。  
\texttt{p32ExecUnit3}モジュールの乗算命令処理は、\texttt{ex\_mult}関数により実現され、以下のように動作する。

\begin{itemize}
  \item 入力の32ビット値$a$, $b$を\texttt{mult32}に渡し、64ビット乗算結果を得る。
  \item 64ビット結果の下位32ビットを\texttt{result}へ、上位32ビットを\texttt{result2}へ格納。
  \item フラグ\texttt{is\_mult}を真に設定し、乗算処理中であることを明示する。
\end{itemize}

乗算処理中の\texttt{is\_mult}フラグは、制御ユニットや後段パイプラインに対して乗算命令の特殊性を示すために用いられる。
例えば、64ビット結果の2つのレジスタへの分割格納や、結果取得までの待機制御などで利用される。これは乗算演算が，ほかの演算と比べて
特定のマシンサイクルで演算終了とならないため，フラグを立てて計算中か明示する必要があるためである．階乗結果は最終的には
HI/LOレジスタに保存されているので実行結果が正しいか確認し，正常に動作していることを確かめた．
除算命令については実装中である．
32ビット除算器は第\ref{div}章にて実装完了している．除算命令も同様に，そのアルゴリズムによってサイクル数が異なる．
よって，実装方針としては乗算命令実装と同様である．まずフラグを定義して，関数の出力をout\_enのように出力するのではなく
乗算器のように，二つの３２ビット長の出力とした．実際には商，剰余を分けて出力している．それを\verb|result|，\verb|result2|に
割り当てて，そこからレジスタへの格納までは乗算器と同様なので確認されたい．
%%============================================================%%

\section{検討・考察}
%%============================================================%%
\section{工夫した点や特に力を注いだ点}
私が特に力を注いだ点はやはりプロセッサの効率化，拡張である．
私はまず逐次シフト減算法に基づく除算器の自作に取り組み，
逐次演算による構成ながらも動作の正確性とデバッグ容易性を両立させる実装を実現した．
さらに，加算命令群が性能上の律速要因となっていることを静的タイミング解析により特定し，
これに対して桁上げ先見加算器（Carry Lookahead Adder）を独自に設計・導入することで，
プロセッサ全体の最大動作周波数を向上させる成果を得た．また，乗算命令についても64ビット結果を適切に扱う機構を整備し，
制御フラグを用いたパイプライン制御との整合性を確保するなど，システム全体の整合的な拡張を図った．
これらの更なる詳細は第\Ref{tuika_hatten}章に記述しているので確認されたい．
これら一連の実装・改良作業を通じて，演算器設計がプロセッサ全体の性能および機能性に与える影響の大きさを実感するとともに，
低位レベルの回路設計と高位レベルのアーキテクチャ設計とが密接に連関していることを学んだ．
%%============================================================%%
\section{本実験の成果と実験を実施して得られたこと}
本実験を通じて、ハードウェア記述言語およびCADツールを用いたマイクロプロセッサ設計の一連の工程を実際に体験することで、
論理回路から高位アーキテクチャに至る設計プロセスへの理解を深めることができた。
また、命令デコードやレジスタファイル、ALUの構築などの基本機能に加え、除算・乗算機能の拡張や加算器の効率化といった
発展的な実装を通じて、設計上の工夫や最適化手法についても実践的に学ぶことができた。
さらに、アセンブラ・シミュレータ・設計支援ツールといった複数のツールを一貫した設定環境で運用することで、
ソフトウェアとハードウェアの連携の重要性を実感する機会ともなった。以上より、本実験の目的は十分に達成されたと考える。
以下，自己評価の表\ref{tab:目標達成度と自己評価}により報告する．  
\begin{table}[t]
    \caption{目標達成度と自己評価}
    \label{tab:目標達成度と自己評価}
    \begin{center}
    {\small
    \begin{tabular}{rl|r}
    \hline
    \hline
    \multicolumn{2}{c|}{項目} & \multicolumn{1}{c}{達成度(自己評価)} \\
    \hline
    1. & ハードウェア設計処理全般(処理の概要と流れ) & 6 \\
    2. & ハードウェア記述言語 (FSL) & 6 \\
    3. & ハードウェア設計ツール類の使用方法 & 6 \\
    4. & プロセッサの命令セットアーキテクチャ & 6 \\
    5. & アセンブリ言語とそれを用いたプログラミング & 6 \\
    6. & プロセッサの動作原理 & 6 \\
    7. & プロセッサの設計 & 6 \\
    8. & 実験報告書 & 5 \\
    \hline
    9. & 総合(項目1.〜8.の合計) & 47 \\
    \hline
    \end{tabular}
    }
    \end{center}
    \end{table}

%%============================================================%%

\end{document}