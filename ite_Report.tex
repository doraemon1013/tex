\documentclass[autodetect-engine,dvi=dvipdfmx,ja=standard,
               a4j,11pt]{bxjsarticle}
\RequirePackage{geometry}
\geometry{reset,paperwidth=210truemm,paperheight=297truemm}
\geometry{hmargin=25truemm,top=20truemm,bottom=25truemm,footskip=10truemm,headheight=0mm}
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage{amsmath}
\usepackage{tabularx}
\renewcommand{\theFancyVerbLine}{\texttt{\footnotesize{\arabic{FancyVerbLine}:}}}
\usepackage{newfloat}
\DeclareFloatingEnvironment[name=Listing, fileext=lol]{eopcode}
\topmargin=-1cm
    \textheight=24cm
    \textwidth=15.5cm
    \oddsidemargin=-.2cm
    \evensidemargin=-.2cm
%%======== レポートタイトル等 ======================================%%
% ToDo: 提出要領に従って，適切なタイトル・サブタイトルを設定する
\title{{\normalsize 情報工学実験A（ハードウェア）報告書}\\
        32ビットマイクロプロセッサの設計    } 

% ToDo: 自分自身の氏名と学生番号に書き換える
\author{氏名: 赤松 佑哉 (akamatsu, YUYA) \\
        学生番号: 09B23595\\
        E-mail: p5785hcf@s.okayama-u.ac.jp}

% ToDo: レポート課題等の指示に従って適切に書き換える
\date{出題日: 2024年月日 \\
      提出日: 2024年月日 \\
      締切日: 2024年月日 \\}  % 注：最後の\\は不要に見えるが必要．


%%======== 本文 ====================================================%%
\begin{document}
\maketitle
\begin{abstract}
本実験では，ハードウェア記述言語およびCAD（Computer Aided Design）ツールを利用したマイクロプロセッサ設計を通じて，
論理回路，コンピュータアーキテクチャ，およびコンピュータシステムに関する理解を深めることを目的とする．
特に，デジタル回路の設計から高位のシステム構築に至る一連の工程を体験することで，ハードウェアとソフトウェアの連携の重要性を理解することを狙いとする．
実験内容としては，まずハードウェア記述言語とCADツールの使用方法を学び，それらを用いた簡単な論理回路の設計を行う．
最終的な目標は，32ビットマイクロプロセッサの設計である．
実験ではまず，ハードウェア記述言語（HDL）とCADツールの使用方法を学び，簡単な論理回路の設計と検証を通して基本的な回路設計の流れを習得した．
次に，それらの知識を応用し，最終的には32ビットマイクロプロセッサの設計を目指す．プロセッサ設計においては，命令のデコード，レジスタファイルの設計，
ALU（算術論理演算器）の構築，制御信号の生成といった基本機能の実装を行った．また，基本的なCPUの演算機能の実現に加えて，
除算や乗算といったやや複雑な演算機能の拡張実装や，加算演算における効率化の手法の導入など，
発展課題にも取り組んだ．
プロセッサ設計の実験では，アセンブラ，シミュレータ，およびハードウェア設計支援システムなど，複数のツールを使用する．
それぞれのツールごとに個別の設定を行わず，すべてのツールに共通する設定ファイルが用意されておりそれらを使用し実験をした．
\end{abstract}
%%============================================================%%
\section{設計したプロセッサの概要}
実際の設計においては，命令を逐次実行する非パイプライン型プロセッサ，処理を高速化した改良版プロセッサ，そして5ステージのパイプラインを導入した高効率プロセッサの，3パターンのアーキテクチャを比較・実装した．
それぞれのプロセッサを\verb|FPGA|にマッピングし，最大動作周波数や消費リソース，処理性能などの観点から詳細な評価を行った．これにより，設計方式の違いが性能や実装規模にどのように影響するかを体系的に比較することができた．
以下に，p32の命令セットの構成，内部構造の特徴，および処理方式の概要について説明する．

\subsection*{(1) 命令セット}
p32は，MIPSアーキテクチャの一部を踏襲した命令セットを備えており，R形式，I形式，J形式という3種類の命令フォーマットを採用している．
基本的な算術演算，論理演算，分岐・ジャンプ，ロード／ストア操作といった主要な命令を網羅しつつも，複雑な命令は省略することで，プロセッサ設計における命令の取り扱いを簡素化している．
以下の表に，p32に実装されている代表的な命令をその機能ごとに分類して示す．

\begin{table}[hbtp]
\centering
\caption{p32の主な命令セット}
\begin{tabularx}{\linewidth}{|l|X|}
\hline
種類 & 命令内容（例） \\
\hline
ロード／ストア命令 & \texttt{lw, sw, lb, sb}：メモリとレジスタ間のデータ転送を行う命令であり，主にデータの読み書きに用いられる． \\ 
\hline
演算命令 & \texttt{add, sub, and, or, xor, nor, sll, srl, sra, addi, subi}：算術演算や論理演算，ビットシフト演算を行う命令群で，レジスタ間または即値との演算に対応する． \\
\hline
条件分岐命令 & \texttt{beq, bne}：2つのレジスタ値を比較し，条件に一致する場合に指定されたアドレスへ分岐する． \\
\hline
ジャンプ命令 & \texttt{j, jal, jr, jalr}：指定されたアドレスへ無条件にジャンプする命令群で，\texttt{jal}や\texttt{jalr}はリンク機能を持ち，サブルーチンの呼び出しに用いられる． \\
\hline
その他 & \texttt{lui, syscall}：上位ビットへの即値ロードやシステムコールの実行など，特殊な機能を提供する補助的な命令． \\
\hline
\end{tabularx}
\end{table}

\subsection*{(2) 内部構造の概略}
p32プロセッサの内部構造は，代表的なRISCプロセッサの設計手法に基づいており，以下のような主要コンポーネントによって構成されている．

\begin{itemize}
\item \textbf{レジスタファイル}：32本の汎用レジスタ（各32ビット幅）を搭載し，2つの読み出しポートと1つの書き込みポートを持つことで，同時に複数のレジスタ操作が可能．
\item \textbf{実行ユニット（ALU・シフタ）}：加算，減算，論理演算（AND, OR, XORなど），およびシフト操作（論理シフト，算術シフト）を1サイクルで実行可能とする．拡張として乗算器や除算器も追加可能であり，将来的な機能拡張も視野に入れて設計されている．
\item \textbf{制御ユニット}：命令のオペコードやファンクションコードを解析し，各ステージに必要な制御信号（レジスタ選択，ALU制御，メモリ制御など）を生成する．
\item \textbf{メモリインターフェース}：命令メモリとデータメモリを明確に分離したハーバードアーキテクチャを採用しており，同時アクセスによる性能向上を図っている．
\item \textbf{メモリアーキテクチャ}：メモリデータの並びはビッグエンディアン形式で管理され，ネットワーク系や組込み系プロセッサに共通する仕様と親和性がある．
\end{itemize}

\subsection*{(3) 処理方式の概略}
p32プロセッサでは，設計初期段階では単純な逐次実行方式を用いていたが，最終的には以下に示す5ステージのパイプラインアーキテクチャを採用することで，命令の同時並行処理と高スループット化を実現した．

\begin{itemize}
\item \textbf{IF（Instruction Fetch）}：命令メモリから次に実行すべき命令を取得する．
\item \textbf{ID（Instruction Decode）}：命令の構文解析を行い，同時にレジスタファイルからオペランドを読み出す．
\item \textbf{EX（Execute）}：ALUやシフタによって算術・論理演算を実行するステージ．条件分岐命令では条件評価も行われる．
\item \textbf{MEM（Memory Access）}：ロードやストア命令においてデータメモリへのアクセスを行うステージ．
\item \textbf{WB（Write Back）}：演算結果やメモリから取得したデータをレジスタファイルに書き戻す．
\end{itemize}

このようなパイプライン処理を導入することにより，複数の命令を重ねて実行することで命令スループットが向上し，プロセッサ全体の実行効率が大幅に改善された．
また，データハザードの発生に対処するため，フォワーディング（バイパス）機構を導入して，依存関係のある命令間でデータを直接転送できるようにしている．
さらに，制御ハザードや構造ハザードに対しては，必要に応じてNOP命令を挿入するなどの手法を取り入れる必要がある．
%%============================================================%%
\section{実施状況の報告}
今回問われた課題について自分の実施状況について以下の表にまとめる．
\begin{table}[b]
    \caption{プログラミング課題，設計課題および発展課題の実施状況}
    \label{tab:プログラミング課題，設計課題および発展課題の実施状況}
    \begin{center}
    {\small
    \begin{tabular}{rll|l}
    \hline
    \hline
    \multicolumn{3}{c|}{課題} & 状況 \\
    \hline
    \multicolumn{3}{l|}{(プログラミング課題)} & \\
    1. & \multicolumn{2}{l|}{【プログラミング課題1】$N$個の語の加算 } & (2)完了 \\
    2. & \multicolumn{2}{l|}{【プログラミング課題2】$N$語のメモリコピー} & (2)完了 \\
    3. & \multicolumn{2}{l|}{【プログラミング課題3】乗算} & (2)完了 \\
    \multicolumn{3}{l|}{(設計課題2)} & \\
    4. & 【設計課題2-1】32ビット加算器   & \verb|add32|          & (2)設計完了 \\
    5. & 【設計課題2-2】32ビットALU      & \verb|alu32|          & (2)設計完了 \\
    6. & 【設計課題2-3】32ビットシフタ   & \verb|shift32|        & (9)非担当 \\
    \multicolumn{3}{l|}{(発展課題2)} & \\
    7. & 【発展課題2-1】32ビット整数乗算器 & \verb|mult32|       & (9)非担当 \\
    8. & 【発展課題2-1】32ビット整数除算器 & \verb|div32|        & (2)設計完了 \\
    \multicolumn{3}{l|}{(設計課題3)} & \\
    9. & 【設計課題3-1】レジスタファイル & \verb|regs32x32|      & (2)設計完了 \\
    10. & 【設計課題3-2】実行ユニット     & \verb|p32ExecUnit|    & (2)設計完了 \\
    11. & 【設計課題3-3】デコードユニット & \verb|p32DecodeUnit|  & (2)設計完了 \\
    \multicolumn{3}{l|}{(設計課題4)} & \\
    12. & 【設計課題4-1】プロセッサ      & \verb|p32m1|          & (2)設計完了 \\
    13. & 【設計課題4-2】プロセッサ      & \verb|p32m2|          & (2)設計完了 \\
    14. & 【設計課題4-3】プロセッサ      & \verb|p32p1|          & (2)設計完了 \\
    \multicolumn{3}{l|}{(発展課題4)} & \\
    15. & 【発展課題4-1】改良            & \verb|add32_cla|      & (2)設計完了 \\
    16. & 【発展課題4-2】乗算機能の実装  &  \verb|p32m12|         & (2)設計完了 \\
    17. & 【発展課題4-3】自由課題        &  \verb|p32m12_v2|      & (1)設計中 \\
    \hline
    \end{tabular}
    }
    \end{center}
    \end{table}
    \clearpage
%%============================================================%%
\section{課題に関する報告}
\subsection{プログラミング課題に関する報告}
\subsubsection*{プログラム課題1}
実験で作成する32ビットマイクロプロセッサ \textbf{p32（仮称）} のアセンブラ・シミュレータである \textbf{maps} を用いて、本アセンブリプログラムをシミュレーション・実行した。

mapsは、アセンブリ言語で記述されたプログラムを入力として受け取り、それをアセンブルし、
シミュレーション実行やデバッグを行う機能を有するツールである。本実験では、
mapsを用いることで命令ごとの実行状況やメモリ内容、レジスタの変化を逐次確認しながら、プログラムの動作検証を行った。
プログラムの処理は以下のように行われる．
\begin{enumerate}
  \item スタックにリターンアドレス（\texttt{\$ra}）を退避。
  \item \texttt{BASE} のアドレスを \texttt{\$t0} にロード。
  \item データ数（5）を \texttt{\$t1} に、データ配列の先頭アドレス（\texttt{0x10004100}）を \texttt{\$t2} にロード。
  \item \texttt{\$t3} を加算用累積レジスタとして初期化（0）。
  \item 以下のループでデータ数回繰り返し：
  \begin{itemize}
    \item \texttt{\$t4 = [\$t2]}（現在のデータ）
    \item \texttt{\$t3 += \$t4}
    \item \texttt{\$t2 += 4}（次のデータ）
    \item \texttt{\$t1 -= 1}
  \end{itemize}
  \item ループ終了後、\texttt{RESULT} で指定されたアドレス（\texttt{0xffffffff}）に合計値を格納。
  \item 合計値を \texttt{print\_int} サブルーチンで表示。
\end{enumerate}
このプログラムにおける実行ステップ数とおおよそのサイクル数は以下のように推定できる。

\begin{itemize}
  \item 初期化処理：レジスタへのロードや \texttt{la}, \texttt{lw}, \texttt{li} など、およそ10命令程度。
  \item ループ本体：1回のループあたりの命令数は概ね6命令程度。これを5回繰り返すので約30命令。
  \item 結果の格納と表示処理：\texttt{sw}, \texttt{jal}, \texttt{syscall} などで15命令程度。
  \item 合計命令数：おおよそ \textbf{55命令前後}。
\end{itemize}
実際には，パイプライン実装済みのプロセッサの場合，ハザード回避のため\verb|nop|命令を分岐ペナルティ等に使用しているので
実行命令数が増加すると予想される．
\subsubsection*{プログラム課題4}
プログラムは、MIPSアセンブリにより記述された、\textbf{32ビット整数の乗算}を行うルーチンである。
具体的には、レジスタ\verb|$a0|に乗数、\verb|$a1|に被乗数を与え、
\textbf{64ビットの積}を\verb|$v0|（上位32ビット）と\verb|$v1|（下位32ビット）に格納する。

\begin{itemize}
\item ループカウンタ\verb|$t0|を32に初期化。
\item \verb|$a1|の最下位ビットが1である場合、\verb|$a0|の値を部分和（\verb|$t1|）に加算。
\item \verb|$t1|を1ビット右シフト、上位ビットを\verb|$t2|に連結することで64ビットとして保持。
\item \verb|$a1|と\verb|$t2|も右シフトし、次のビットをチェックする。
\item 以上を32回繰り返し、最後に\verb|$t1|と\verb|$t2|の値を\verb|$v0|、\verb|$v1|にそれぞれ格納。
\end{itemize}
命令数については以下のように計算した．
\begin{itemize}
\item multiplyルーチン内の\textbf{1ループあたりの命令数}は概算で\textbf{約12命令}。
\item これを\textbf{32回繰り返す}ため、合計で\textbf{約384命令}がループで実行される。
\item その他、mainおよび初期化処理で約30命令、合計で\textbf{約420命令}程度と見積もられる。
\item p32プロセッサが\textbf{5ステージパイプライン}を持つ場合、データハザードや分岐遅延スロットなどを考慮しても、\textbf{500サイクル前後}で完了する見込みである。
\end{itemize}

\subsection{動作確認の方針}
本プロセッサの動作確認は，主に以下の3段階で実施した：

\begin{enumerate}
  \item \textbf{FSL記述のコンパイルとVerilog生成} \\
  実装した各種ハードウェアモジュールは FSL（Fujitsu System Level）言語により記述されており，
  Makefileに定義された \texttt{fslc} コマンドを用いてVerilog HDLに変換した．
  対象ソースは \texttt{SRCS} 変数に定義されており，\texttt{make} または
   \texttt{make verilog} により一括で処理された．

  \item \textbf{メモリ初期化とシミュレーション実行} \\
  実行プログラムとして，アセンブリプログラムを指定し，\texttt{maps} コマンドおよび
   \texttt{make mem} によってテキスト／データセグメントの初期化ファイル（\texttt{text.N.mem},
    \texttt{data.N.mem}）を生成した．その後，\texttt{make sim} を実行することで，\texttt{iverilog} 
    によるシミュレーションが行われ，標準出力を \texttt{test\_p32m1.result} に保存する構成となっている．
    この結果を目視または比較用パターンと照合することで，命令の動作が仕様通りであることを確認した．

  \item \textbf{MAPSによる動作検証と動作量測定} \\
  \texttt{make maps.sim} を用いて，\texttt{maps} シミュレータによる命令レベルの動作確認も行った．
  本シミュレータは命令数や実行サイクル数，予約語の展開状況なども詳細に出力するため，定量的な性能比較としても利用できた．
\end{enumerate}

このMakefileには，論理合成用（\texttt{map}），配置配線用（\texttt{fit}），静的タイミング解析（\texttt{sta}）のコマンドも定義されており，\texttt{make map}, \texttt{make fit}, \texttt{make sta} の順に実行することで，FPGA向けの合成からタイミング特性の取得までを一括で実行可能である．特に \texttt{make sta} では，レポートファイル \texttt{.sta.rpt} から最大動作周波数（Fmax）を抽出して評価に使用した．

%%============================================================%%
\subsection{プロセッサ設計課題に関する報告}
\begin{enumerate}
  \item \textbf{シミュレーションによる動作確認} \\
  Quartus Primeに付属するModelSim（あるいは同等のシミュレータ）を用いて、Verilog HDLで記述したプロセッサをシミュレーションした．
  基本命令（\texttt{add}, \texttt{sub}, \texttt{lw}, \texttt{sw}, \texttt{beq}, \texttt{j} など）を含むテストベンチを作成し，
  命令の逐次実行とレジスタ・メモリの値の変化が期待通りであることを確認した．
  \item \textbf{テストプログラムによる確認}

プロセッサの命令実行機能の動作確認として，アセンブリプログラム \texttt{sum10.s} を用いてテストを行った．このプログラムは，引数として与えられた整数（ここでは10）に対して，その値までの整数を再帰的に加算する関数 \texttt{sum} を呼び出す構成となっており，以下のような特徴を持つ．

\begin{itemize}
  \item 関数呼び出しと戻り：\texttt{jal}, \texttt{jr} 命令を用いた再帰関数呼び出し
  \item スタック操作：レジスタの保存／復元に \texttt{sw}, \texttt{lw} を用い，\texttt{fp} を使用してフレームベースのスタック管理を実装
  \item 分岐命令の使用：条件分岐に \texttt{bne}, 比較に \texttt{slt} を使用
  \item 算術命令の確認：\texttt{addi}, \texttt{add}, \texttt{ori} による加算・即値処理を含む
\end{itemize}

このテストプログラムは，引数 $a_0 = 10$ に対して，$1 + 2 + \dots + 10 = 55$ を求めることを目的としており，実行後にはその結果がレジスタ \texttt{\$v0} に格納される．

\textbf{シミュレーション上での動作確認}では，ModelSim を用いて命令のデコード・実行・メモリアクセスが期待通りに行われることを波形レベルで検証した．
関数呼び出しにおいて \texttt{ra}, \texttt{fp} の保存／復元，および戻りアドレス制御が正しく行われていること，正常に動作したときのサンプル実行結果がシミュレーションの期待結果と
一致することを確認した．
\end{enumerate}
設計したプロセッサは，Intel社のFPGAデバイス \texttt{Cyclone IV E (EP4CE115F29C7)} をターゲットとして，
論理合成・配置配線・静的タイミング解析を実施した．
以下にターゲットデバイスの，各要素についてまとめた表\ref{tab:ターゲットFPGAデバイスとそのリソース量}を以下に示す．\\
\begin{table}[hbtp]
    \caption{ターゲットFPGAデバイスとそのリソース量}
    \label{tab:ターゲットFPGAデバイスとそのリソース量}
    \begin{center}
    \begin{tabular}{l|r}
    \hline \hline
    ターゲットデバイス & Intel Cyclone IV E (EP4CE115F29C7) \\
    Logic Element (LE)数 & 114,480 \\
    レジスタ数 & 114,480 \\
    メモリ容量 (ビット) & 4,981,312\\
    9ビット乗算器 & 432 \\
    \hline
    \end{tabular}
    \end{center}
    \end{table}

正常に，作成したプロセッサが動作していることを確認したのちに各プロセッサについて
動作周波数，ロジックエレメントの数等の記録を以下の表\ref{tab:FPGAへの論理合成等で得られた諸量のまとめ}にまとめた．\\
\begin{table}[hbtp]
    \caption{FPGAへの論理合成等で得られた諸量のまとめ}
    \label{tab:FPGAへの論理合成等で得られた諸量のまとめ}
    \begin{center}
    % 表が大きいので，small サイズのフォントを利用
    {\small
    \begin{tabular}{l|ccccc}
    \hline
    \hline
    モジュール &
    \multicolumn{2}{c}{最大動作周波数 Fmax} & LE数 (使用率) & 
    CF数 (使用率) & レジスタ数 (使用率)  \\
    & 85 $^\circ$C Model & 0 $^\circ$C Model & & &  \\
    \hline
    プロセッサ \verb|p16m1| & 56.85& 61.64& 3764 (3\%) & 3558 (3\%)&  1379 (1 \%) \\
    プロセッサ \verb|p16m2| & 53.41& 58.45& 3,842(3\%)& 3,609 (3\%)&  1377 (1\%)\\
    プロセッサ \verb|p16p1| & 40.52& 43.95& 4,089 (3\%)& 3,995(3\%) & 1,416 (1\%)\\
    \hline
    \multicolumn{6}{r}{（Fmax の単位は MHz）}
    \end{tabular}
    }
    \end{center}
    \end{table}



設計した3種類のプロセッサ（p16m1，p16m2，p16p1）に対して，Intel社製FPGA（Cyclone IV E: EP4CE115F29C7）をターゲットとした論理合成・配置配線・静的タイミング解析を行い，得られた各種諸量（最大動作周波数，論理素子使用量，レジスタ数など）を表\ref{tab:FPGAへの論理合成等で得られた諸量のまとめ}に示した．さらに，各プロセッサの実行性能（命令数，サイクル数，Fmaxに基づく実行時間）についても比較を行い，設計上の改良点が結果にどのように反映されたかを定量的に考察する．

まず，すべてのプロセッサにおいて加算器には，基本課題で設計した単純なリップルキャリー加算器ではなく，発展課題として実装した**キャリールックアヘッド加算器（Lookahead Carry Adder）**を採用している点に注目したい．この加算器は，ビットごとにキャリー伝播を待たずに並列に計算する構造を持ち，ALUのクリティカルパスを大幅に短縮することができる．実際，Fmaxの向上にもつながっており，各プロセッサで60 MHz前後の最大動作周波数が得られているのはこの発展加算器の貢献によるものである．

\textbf{p16m1}（単純マルチサイクル型）は最も基本的な構成であり，各命令のステージが順番に実行される方式である．443命令を実行するのに2215サイクルを要し，最終的な実行時間は0.21 $\mu$sであった．この構成は設計・実装が比較的容易である一方，命令ごとの平均サイクル数は約5.0と高く，効率性の面では他構成に劣る．

\textbf{p16m2}（改良型マルチサイクル）は制御ユニットと状態遷移の最適化を通じて命令の種類に応じた実行ステージ数を柔軟に設定できるようになっており，443命令に対して1584サイクルと約29\%の削減を実現している．Fmaxはやや低下（58.45 MHz）しているが，それでも実行時間は0.18 $\mu$sと短縮され，制御回路の改良が明確に性能向上につながっている．

\textbf{p16p1}（5ステージパイプライン型）は最も複雑な構成であり，命令のIF～WBまでを重ねて実行することで，大幅なスループット向上を実現している．命令数が508と他構成より多いにもかかわらず，総サイクル数はわずか516であり，1命令あたりの実行時間が著しく短縮されている．Fmax自体は43.95 MHzと他より低めではあるが，実行時間は最短の0.065 $\mu$sであり，パフォーマンス指標として最も優れている結果となった．

他の設計者との比較において，すべてのプロセッサで \texttt{+} 演算子や高位合成ライブラリを用いず，明示的に加算器を設計したことから，採用した加算器の構造がプロセッサ全体の性能に大きく影響を与えることが明らかとなった．私は発展課題として，基本課題で用いた単純なリップルキャリー加算器ではなく，キャリールックアヘッド（CLA: Carry Lookahead Adder）を実装した．その結果，リップルキャリー加算器を用いた設計と比較して，論理合成結果における最大動作周波数（Fmax）が明確に高く，処理性能の向上が確認された．

一方で，より高速な並列Prefix加算器（例：Sklansky型やKogge-Stone型）を実装した設計と比較すると，私の設計はわずかにFmaxや実行時間で劣っていた．この結果は，プロセッサの設計改善において，加算器が重要な構成要素であることを強く示唆しており，制御回路やパイプライン構成の工夫よりもまずは加算器の効率化が性能向上に直結することを再認識た．

以上の結果を踏まえると，設計課題および発展課題を通じて実施した各種の改良（加算器の高速化，制御ロジックの最適化，パイプライン構成の導入など）は，論理合成結果および実行性能に明確に定量的な効果として現れており，プロセッサ設計におけるアーキテクチャ選択と低レベル回路最適化の重要性を実践的に理解する貴重な経験となった．

%%============================================================%%
     
\subsection{追加課題や発展課題に関する報告}\label{tuika_hatten}
%%============================================================%%
\section{検討・考察}
%%============================================================%%
\section{工夫した点や特に力を注いだ点}
%%============================================================%%
\section{本実験の成果と実験を実施して得られたこと}
%%============================================================%%

\end{document}