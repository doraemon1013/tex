\documentclass[autodetect-engine,dvi=dvipdfmx,ja=standard,
               a4j,11pt]{bxjsarticle}
\RequirePackage{geometry}
\geometry{reset,paperwidth=210truemm,paperheight=297truemm}
\geometry{hmargin=25truemm,top=20truemm,bottom=25truemm,footskip=10truemm,headheight=0mm}
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage{amsmath}
\usepackage{listings}
\lstset{
  breaklines=true,      % 長い行を折り返す
  basicstyle=\ttfamily\small
}
\renewcommand{\theFancyVerbLine}{\texttt{\footnotesize{\arabic{FancyVerbLine}:}}}
\usepackage{newfloat}
\DeclareFloatingEnvironment[name=Listing, fileext=lol]{eopcode}
%%======== レポートタイトル等 ======================================%%
% ToDo: 提出要領に従って，適切なタイトル・サブタイトルを設定する
\title{プログラミング言語レポート}

% ToDo: 自分自身の氏名と学生番号に書き換える
\author{氏名: 赤松 佑哉 (akamatsu, YUYA) \\
        学生番号: 09B23595}

% ToDo: レポート課題等の指示に従って適切に書き換える
\date{出題日: 2024年5月9日 \\
      提出日: 2024年5月日 \\
      締切日: 2024年6月4日 \\}  % 注：最後の\\は不要に見えるが必要．


%%======== 本文 ====================================================%%
\begin{document}
\maketitle
\section{概要}
講義を通して学んだ関数型言語\verb|SML|言語を実際の問題解決を通して実践した．
今回，\verb|C|言語の標準ライブラリに存在する文字列操作関数，\verb|strcat|
，\verb|strcmp|，\verb|strcpy|，\verb|strexi|，\verb|strlen|
，\verb|sort|と同等の操作をリストに行う\verb|SML|プログラムを作成した．
いかに各関数の概要を示す．
\begin{itemize}
    \item \textbf{listcat} ：\verb|strcat|に相当し，2つのリストを連結する．
    \item \textbf{listcmp} ：\verb|strcmp|に相当し，2つのリストが要素・順序ともに等しいか判定する．
    \item \textbf{listcpy} ：\verb|strcpy|に相当し，リストの複製（コピー）を行う．
    \item \textbf{listexi} ：\verb|strexi|のように，条件を満たす要素がリスト中に存在するかを確認する（高階関数を用いる）．
    \item \textbf{listlen} ：\verb|strlen|に相当し，リストの長さ（要素数）を返す．
    \item \textbf{listsort}：\verb|sort|に対応し，マージソートによりリストを昇順に並べ替える．
\end{itemize}
作成したプログラムは第\ref{code}章に添付している．
%%--------------------------------------------------------------------------------------------------------------------------
\section{\texttt{listcat.sml}の実装}

二つのリストを引数として受け取り、それらを結合した一つのリストを返す \verb|listcat| 関数を実装した。パターンマッチングを用いて引数の構造に応じた場合分けを行い、異なる処理を実現している。

片方が空リストであれば、もう片方のリストをそのまま返す。両方のリストに要素がある場合は、第一引数の先頭要素を取り出し、それを再帰的に呼び出された \verb|listcat| の戻り値の先頭に加えることでリストを構築する。

この再帰処理は、第一引数が空リストとなった時点で終了し、第二引数がそのまま返される。このとき、再帰は打ち切られ、結合されたリストが得られる。

以下のテスト入力により動作確認を行った。

\begin{Verbatim}
val test1 = listcat([1,2,3], [4,5])
val test2 = listcat([1,2,3], [])
val test3 = listcat([], [1,2,3])
val test4 = listcat([], [])    
\end{Verbatim}
実行結果は次のようになった．
\begin{Verbatim}
$ sml listcat.sml 
Standard ML of New Jersey v110.79 [built: Sat Oct 26 12:27:04 2019]
[opening listcat.sml]
val listcat = fn : int list * int list -> int list
val test1 = [1,2,3,4,5] : int list
val test2 = [1,2,3] : int list
val test3 = [1,2,3] : int list
val test4 = [] : int list   
\end{Verbatim}
結果を見るときちんと二つのリストを合併し一つのリストの作成に成功している．また空リストの時もきちんと動作してることがわかる．
以上が二つのリストの合併\verb|listcat|の実装，解説である．作成した\verb|SML|ソースコードは第\ref{listcat_code}章に添付している．
%%------------------------------------------------------------------------------------------------------------------------
\section{\texttt{listcmp.sml}の実装}
二つのリストを引数として受け取り，対応する要素の差をすべて合計し返す \verb|listcmp| 関数を実装した．
\verb|strcmp| 関数のような等価判定ではなく，数値的な差異を合計してリスト間の「違いの度合い」を測ることができる．

関数内部ではパターンマッチングを用い，両方が空リストなら \verb|0| を返す．一方が空リストで他方に要素が残っている場合には，残りの要素をすべて加算して返す．
両方に要素がある場合には，先頭要素の差を取り，再帰的に残りのリストに対して同様の処理を行っている．

以下の入力を引数として渡し，動作確認を行った．
\begin{Verbatim}
val test1 = listcmp([1,2,3], [1,2,3])
val test2 = listcmp([1,2,3], [1,2,2])
val test3 = listcmp([1,2,3], [1,2,4])
val test4 = listcmp([1,2,3], [1,2])
val test5 = listcmp([1,2], [1,2,3])
val test6 = listcmp([], [])    
\end{Verbatim}
実行結果は次のようになった．
\begin{Verbatim}
$ sml listcmp.sml 
Standard ML of New Jersey v110.79 [built: Sat Oct 26 12:27:04 2019]
[opening listcmp.sml]
val listcmp = fn : int list * int list -> int
val test1 = 0 : int
val test2 = 1 : int
val test3 = ~1 : int
val test4 = 3 : int
val test5 = 3 : int
val test6 = 0 : int    
\end{Verbatim}
結果を見るときちんと二つのリストの辞書的な差異を数値として出力できている．リストどおしの要素数が違う場合もきちんと動作している．
以上がリストを比較する\verb|listcmp|関数の実装，解説である．作成した\verb|SML|ソースコードは第\ref{listcmp_code}章に添付している．
%%=================================================================%%
\section{\texttt{listcpy.sml}の実装}
リストの内容をそのままコピーした新しいリストを返す関数 \verb|listcpy| を実装した．
この関数は，\verb|C|言語における \verb|strcpy| のように元のリストを変更せずに，その要素を順にコピーして新しいリストを構築する機能を持つ．

\verb|SML| ではリストはイミュータブル（不変）であるため，コピー処理は新しいリストを再帰的に構築する形で実現される．
具体的には，パターンマッチングにより，空リストに到達した場合には空リストを返す終了条件とし，非空の場合には先頭要素を新しいリストの先頭に追加しながら再帰呼び出しを行っている．

以下のテストコードにより動作確認を行った．
\begin{Verbatim}
val test1 : int list = listcpy[]
val test2 = listcpy[1,2,3,4]  
\end{Verbatim}
実行結果は次のようになった．
\begin{Verbatim}
$ sml listcpy.sml
Standard ML of New Jersey v110.79 [built: Sat Oct 26 12:27:04 2019]
[opening listcpy.sml]
val listcpy = fn : 'a list -> 'a list
val test1 = [] : int list
val test2 = [1,2,3,4] : int list    
\end{Verbatim}

この結果より，空リストに対しても，任意の整数リストに対しても正しくコピーされたリストを返すことが確認できた．
このように，再帰を用いた基本的なリスト操作を通じて，\verb|SML| の関数型プログラミングの特性を活かした実装を行った．
作成した \verb|SML| ソースコードは第\ref{listcpy_code}章に添付している．
%%=================================================================%%
\section{\texttt{listexi.sml}の実装}
\texttt{listexi}関数は，整数とリストを引数に取り，その整数がリスト中に何回出現するかをカウントして返す関数である．
パターンマッチングを用いて，リストの構造に応じた再帰処理を行うことで実現している．

まずリストが空である場合（終了条件）には 0 を返す．
それ以外の場合には，リストの先頭要素と比較し，一致していれば 1 を加算し，再帰的に残りのリストで同様の判定を行う．
この処理により，リスト中の該当要素の合計出現回数を求めることができる．

以下にテスト入力とその実行結果を示す．
\begin{Verbatim}
    val test1 = listexi(1, [1,2,3])
    val test2 = listexi(0, [1,2,3])
    val test3 = listexi(1, [1,2,1])
    val test4 = listexi(1, [])    
\end{Verbatim}
実行結果は次のようになった．
\begin{Verbatim}
    L$ sml listexi.sml 
Standard ML of New Jersey v110.79 [built: Sat Oct 26 12:27:04 2019]
[opening listexi.sml]
listexi.sml:4.27 Warning: calling polyEqual
val listexi = fn : ''a * ''a list -> int
val test1 = 1 : int
val test2 = 0 : int
val test3 = 2 : int
val test4 = 0 : int
\end{Verbatim}
実行結果より，\texttt{listexi}関数は指定した要素の出現回数を正しくカウントしていることが確認できる．
この関数はリスト探索と条件分岐，再帰処理の組み合わせにより実装されており，基本的なリスト操作の理解に適した例である．
作成した \texttt{SML} ソースコードは第\ref{listexi_code}章に添付している．
%%=================================================================%%
\section{\texttt{listlen.sml}の実装}
\texttt{listlen}関数は，引数として与えられたリストの長さ（要素数）を求めて返す関数である．
この関数は，パターンマッチングと再帰処理を用いてシンプルに実装されており，リスト操作の基礎的な理解に適している．

リストが空であれば長さは 0 を返す．
そうでない場合（リストが少なくとも1つの要素を持つ場合），リストの先頭を除いた残りのリストに対して再帰的に \texttt{listlen} を呼び出し，
その結果に 1 を加えることで全体の長さを求めている．

以下にテスト入力とその実行結果を示す．
\begin{Verbatim}
val test1 = listlen([])
val test2 = listlen([1])
val test3 = listlen([1, 2])
val test4 = listlen([1,2,3])
\end{Verbatim}
実行結果は次のようになった．
\begin{Verbatim}
val test1 = 0 : int
val test2 = 1 : int
val test3 = 2 : int
val test4 = 3 : int  
\end{Verbatim}
実行結果から，空リストを含むさまざまな長さのリストに対して，\texttt{listlen}関数が正しく要素数を返していることが確認できる．
再帰を通じてリストを1つずつ処理しながら合計を求める構造は，SMLにおける関数型プログラミングの基本的な設計手法を反映している．
作成した \texttt{SML} ソースコードは第\ref{listlen_code}章に添付している．
%%=================================================================%%
\section{\texttt{listsort.sml}}
整数リストを昇順に整列する関数 \verb|listsort| を実装した．この関数はマージソート（Merge Sort）アルゴリズムに基づいており，
以下の3つの関数から構成される
\begin{itemize}
  \item \texttt{merge}: 2つの整列済みリストを結合して新たな整列済みリストを生成する補助関数
  \item \texttt{listsplit}: リストをおよそ半分に分割する補助関数
  \item \texttt{listsort}: 与えられたリストを再帰的に分割し，整列しながら結合するメイン関数
\end{itemize}
各関数を以下の第\ref{listsplit}章，\ref{mergesort}章に詳細を記述している
以下はテスト入力とその実行結果である.
\begin{Verbatim}
val test1 = listsort[5,4,3,2,1]
val test2 = listsort[2,3,1,2]
val test3 = listsort[]
val test4 = listsort[4,3,2,1]
\end{Verbatim}
実行結果は次のようになった．
\begin{Verbatim}
$ sml listsort.sml 
Standard ML of New Jersey v110.79 [built: Sat Oct 26 12:27:04 2019]
[opening listsort.sml]
val merge = fn : int list * int list -> int list
val listsplit = fn : 'a list -> 'a list * 'a list
val listsort = fn : int list -> int list
val test1 = [1,2,3,4,5] : int list
val test2 = [1,2,2,3] : int list
val test3 = [] : int list
val test4 = [1,2,3,4] : int list  
\end{Verbatim}
結果より，\texttt{listsort}関数が再帰的な分割・統合処理を通じて，任意の順序のリストを正しく昇順に整列していることが確認できた．
このように，関数型言語SMLにおいても効率的な整列アルゴリズムを簡潔に表現できることが示された．
ソースコードは第\ref{listsort_code}章に示す．
%%=================================================================%%
\subsection{\texttt{listsplit.sml}}\label{listsplit}
与えられたリストを約半分ずつの二つのリストに分割する \verb|listsplit| 関数を実装した．
この関数は，マージソートなどの分割統治法を用いるアルゴリズムの前処理として有用である．

関数の内部には，分割処理を再帰的に行う補助関数 \verb|loop| を定義しており，\verb|lst| を先頭から2つずつ取り出しながら
左右のリスト \verb|left|，\verb|right| に交互に振り分けていく方式を採用している．
処理終了後に \verb|rev| を用いてリストを元の順序に戻している点が特徴である．
rev（リストの反転）を使う利点は、リストの末尾に要素を追加するコストを回避しつつ、意図した順序のリストを得られるという点からだ．
%%=================================================================%%
\subsection{マージソートの実装}\label{mergesort}
%%=================================================================%%
\section{\texttt{SML}や講義に関する所感}

%%=================================================================%%
\section{作成したプログラムのソースコード} \label{code}
\subsection{\texttt{listcat.sml}のソースコード} \label{listcat_code}
\begin{Verbatim}[numbers=left, xleftmargin=8mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
fun listcat([], x) = x : int list
   |listcat(x, []) = x : int list
   |listcat(x::xs, y) = x :: listcat(xs, y)
\end{Verbatim}
\subsection{\texttt{listcmp.sml}のソースコード} \label{listcmp_code}
\begin{Verbatim}[numbers=left, xleftmargin=8mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
fun listcmp([],[]) = 0
   |listcmp([], x::xs) = x + listcmp([], xs)
   |listcmp(x::xs ,[]) = x + listcmp(xs, [])
   |listcmp(x::xs, y::ys) = 
    let
        val diff = x - y
    in
        diff + listcmp(xs, ys)
    end;
\end{Verbatim}
\subsection{\texttt{listcpy.sml}のソースコード} \label{listcpy_code}
\begin{Verbatim}[numbers=left, xleftmargin=8mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
fun listcpy [] = []
   |listcpy (x::xs) = x :: listcpy (xs);
\end{Verbatim}
\subsection{\texttt{listexi.sml}のソースコード} \label{listexi_code}
\begin{Verbatim}[numbers=left, xleftmargin=8mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
fun listexi(x, []) = 0
   |listexi(x, y::ys) = 
    let
        val check = if (x = y) then 1 else 0
    in
        check + listexi(x, ys)
    end;
\end{Verbatim}
\subsection{\texttt{listlen.sml}のソースコード} \label{listlen_code}
\begin{Verbatim}[numbers=left, xleftmargin=8mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
fun listlen([]) = 0
   |listlen(x::xs) = 1 + listlen(xs)
\end{Verbatim}
\subsection{\texttt{listsort.sml}のソースコード} \label{listsort_code}
\begin{Verbatim}[numbers=left, xleftmargin=8mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
fun merge([], ys) = ys
  | merge(xs, []) = xs
  | merge(x::xs, y::ys) =
      if x <= y then x :: merge(xs, y::ys)
                else y :: merge(x::xs, ys);

fun listsplit lst =
  let
    fun loop([], left, right) = (rev left, rev right)
      | loop([x], left, right) = (rev (x::left), rev right)
      | loop(x::y::rest, left, right) = loop(rest, x::left, y::right)
  in
    loop(lst, [], [])
  end;

fun listsort([]) = []
   |listsort([x]) = [x] 
   |listsort L = 
    let 
        val (left, right) = listsplit L
    in
        merge(listsort left, listsort right)
    end;
\end{Verbatim}
\subsection{\texttt{listsplit.sml}のソースコード} \label{listsplit_code}
\begin{Verbatim}[numbers=left, xleftmargin=8mm, numbersep=6pt,
    fontsize=\small, baselinestretch=0.8]
fun listsplit lst =
  let
    fun loop([], left, right) = (rev left, rev right)
      | loop([x], left, right) = (rev (x::left), rev right)
      | loop(x::y::rest, left, right) = loop(rest, x::left, y::right)
  in
    loop(lst, [], [])
  end;


val test1 = listsplit([1,2,3,4])
val test2 = listsplit([1,2,3,4,5])
val test3 = listsplit([])
val test4 = listsplit([1])
\end{Verbatim}
\end{document}
%%=================================================================%%

